### 计算机体系结构 
#### 目前的x处理器的ISA如下
1. 寄存器(均为32位)

   通用寄存器：**ra**, **rb**, **rc**, **rd**

   栈指针寄存器：**sp**

   基址指针寄存器：**bp**

   源址索引寄存器：**si**

   目标索引寄存器：**di**

   中断寄存器： **ih**

   页目录寄存器： **pdir**

   标志寄存器： **flags**

   | flags | 31   | 12   | 11   | 9    | 7    | 6    | 0    |
   | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 标志位   | PG   | PL   | OF   | IF   | SF   | ZF   | CF   |
   | 含义    | 分页   | 特权级  | 溢出   | 中断   | 符号   | 零    | 进位   |

   ​

2. 指令编码

   | 指令                | 机器码         | 字节数  |
   | ----------------- | ----------- | ---- |
   | halt              | 0x00        | 1    |
   | nop               | 0x10        | 1    |
   | rrmov %ra, %rb    | 0x20+rarb   | 2    |
   | irmov V, %rb      | 0x30+Frb+V  | 6    |
   | store %ra, D(%rb) | 0x40+rarb+D | 6    |
   | load D(%rb), %ra  | 0x50+rarb+D | 6    |
   | ALU %ra, %rb      | 0x6fn+rarb  | 2    |
   | jXX Dest          | 0x7fn+Dest  | 5    |
   | call Dest         | 0x80+Dest   | 5    |
   | ret               | 0x90        | 1    |
   | push %ra          | 0xa0+raF    | 2    |
   | pop %ra           | 0xb0+raF    | 2    |
   | in V, %ra         | 0xc0+Fra+V  | 3    |
   | out %ra, V        | 0xd0+raF+V  | 3    |

ALU里的fn对照表

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| add  | sub  | and  | or   | not  | xor  | shl  | shr  |

JXX里的fn对照表

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| jmp  | je   | jl   | jg   | jne  | jle  | jge  |



#### 为什么要这么设计ISA呢，理由如下

##### 寄存器

1. Y86的寄存器

   eax, ebx, ecx, edx, esi, edi, esp, ebp, 条件码ZF SF OF

2. THINPAD的寄存器

   rx, ry, rz, SP, 中断寄存器IH, 返回值寄存器RA, 标志寄存器T

3. V9处理器

   a, b, c, sp, 状态寄存器flags, 页目录寄存器pdir, 浮点寄存器f, g

4. 比较以上3个处理器中的寄存器，考虑到较多的寄存器可以为编程提供方便，但x处理器不计划提供浮点运算，所以计划x处理器包含以下寄存器：

   ra, rb, rc , rd, si, di, sp, bp, ih, flags, pdir

5. **程序计数器PC究竟算不算寄存器？**

   我重新翻阅了《计算机硬件系统实验教程》和《CSAPP》这两本书，两书中均未把PC列入寄存器中。但互联网上有些解释把PC列入寄存器的范围。我感觉PC应该不是寄存器，而是比寄存器更复杂的结构。这个问题我还不是很清楚，但相信应该可以在计算机组成原理的实验中得到解决。

##### 指令集 

1. 运算指令

   * Y86: addl, subl, andl, xorl

   * THINPAD: addiu, addiu3, addsp3, addsp, addu, and, cmp, cmpi, neg, not, or,  sll, sllv, slt, slti, sltu, sra, srav, srl, srlv, subu, xor

   * 比较以上两个处理器的指令，考虑到最简化的原则，所以计划x处理器实现以下指令：

     add, sub, and, or, not, xor, shl, shr

   * **关于not指令的思考**：

     not指令不是必需的，例如可以用如下指令来代替：

     ```
     // not %ra
     irmov 0, %rb	// 将立即数0传入寄存器rb
     xor %rb, %ra	// 寄存器ra和rb进行异或运算，将结果存入ra中
     ```

     然而考虑到在实际编程的时候，not指令的使用是很频繁的。为提高程序的**执行效率**，应该设计not指令。

2. 跳转指令

   * Y86: jmp, jle, jl, je, jne, jge, jg, call, ret

   * THINPAD: b, beqz, bnez, bteqz, btnez, jr, jalr, jrra

   * 比较以上两个处理器的指令，计划x处理器实现以下指令：

     jmp, je, jl, jg, jne, jle, jge, call, ret

3. 中断管理指令

   * THINPAD: int, mfih, mtih
   * V9处理器: cli, sti, rti, ivec, trap, idle
   * 比较以上两个处理器，可以发现一个有趣的现象：THINPAD没有iret指令，而V9没有int指令。而从通常理解来看，int指令和iret指令应该是成对出现的。于是我考虑是否可以**不添加额外的指令而实现中断的功能**。原理是：通过in指令控制外设是否产生中断，通过标志寄存器的IF位控制CPU是否接收中断，通过IH寄存器保存中断例程入口。x处理器目前只有内核态，没有用户态，也没有指令特权级的区别，即使用户程序也有最高权限，这是**X处理器的缺限**，应当在以后的版本中得到解决。

   * **关于中断的相关概念。**

     计算机不是自顾自的在干活，它需要对外界做出响应，这是人类对计算机的**基本需求**，我想这就是中断无可取代的根本原因。**中断源**就是能够触发中断的软件或硬件。**中断的基本步骤**：1. 查询中断控制器，读取中断向量，2. 依据中断向量，从IDT找到中断描述符，3. 依据中断描述符，从GDT中找到段描述符，4. 依据段描述符，跳转到中断服务例程，5. 通过CPL和DPL决定是否进行内核栈和用户栈之间的转换，6. 将寄存器保存在栈中，7. 修改程序指针，开始执行中断。8. 中断执行完毕，将栈中保存的值弹出到寄存器，9. 如果发生了特权级转换，还需要修改栈指针寄存器的值，9, 修改程序指令，跳回原断点处继续执行。**中断优先级**从高到低的次序是：1,除调试错误外的错误，2,陷入指令，3,对当前指令的陷入调试，4,对下一条指令的错误调试，5,不可屏蔽中断，6,可屏蔽外部中断。

   * **中断在v9机器上怎么执行的？**

     在v9上只有可屏蔽中断，中断源只有两个：时钟和键盘。没有中断向量表，只有一个中断处理例程，由IVEC指定。系统调用是由TRAP指令来指定的。个人认为，IVEC+TRAP完成的是x86机器上INT指令的功能。IVEC+RTI完成的是x86机器上IRET的功能。CLI和STI的功能与x86机器上的对应指令是一致的。

   * **中断在xv6中是怎么执行的？**

     xv6中虽然有中断向量表，但中断向量表并未起到作用，因为所有的中断向量都指向了例程alltraps。alltraps又调用了函数trap()，是trap函数完成的中断类型的分配工作。

   * **为x处理器的标志寄存器设置了用户态和内核态切换的标志位，这是否足以实现内核态和用户态的切换呢？**
     为解决这个问题，我又重新学习了ucore_os_docs里关于保护模式的内容，以及ucore_lab1里内核态和用户态切换的代码。发现我一直以为段页式内存分配就是保护模式的全部内容，这种理解是错误的。段页式内存管理+用户态内核态切换才是保护模式的全部内容。段页式管理把内存从形式上区分开，用户态内核态把内存从权限上区分开。内核态用户态的区别还包括指令执行的权限，目前我只想到halt指令是不可以在用户态执行的。内核态用户态的切换最终依赖于中断。这需要考虑中断的问题。

   * **为x处理器的标志寄存器设置了中断标志位，这是否足以实现中断的功能呢？**
     我大概设想了一下中断功能的实现：1,通过rrmov和or指令打开中断标志位，2，使用push指令保存当前寄存器的值，3,使用call指令调用中断例程。我考虑这样操作中断是有很大问题的。1,是没有什么安全性可言，用户态的程序可以很容易地使用中断。2,是如果中断切换过程中如果被其它中断打断，这应该有比较大的问题。3,是call指令调用中断很容易和调用普通例程混淆，没有好的区分方法。还得再好好考虑一下中断的指令。x86处理器为什么要设置STI和CLI指令，我推测STI和CLI一定是特权指令，x86处理器并没有使用mov指令修改寄存器就是为了保护寄存器不被随意修改。我感觉在同一个寄存器内设置不同权限的标志位比较混乱，应该把拥有特权标志位的寄存器单独拿出来。

   * **实现内核态和用户态的切换最简单的方法是什么？其它处理器是怎么做的(MIPS,ARM,RISC V等)？**

     MIPS的做法和X86是类似的，只是所有中断都在0号中断里，系统调用在8号中断，其它都是异常。arm的做法和X86也是类似的，只是用了很多寄存器保存中断的各种状态。

4. 访存指令

   * Y86: mrmovl, rmmovl, pushl, popl

   * THINPAD: lw, lw_sp, sw, sw_rs, sw_sp

   * 比较以上两个处理器的指令，计划x处理器实现以下指令：

     load, store, push, pop

5. 内存管理指令

   - Y86和THINPAD均无内存管理指令

   - V9CPU的内存管理指令：SPAG, PDIR

   - 考虑能否**不增加额外指令使x处理器实现分页管理的功能**，原理如下：

     将页目录保存到pdir寄存器中，通过标志寄存器的PG位控制是否开启分页。

6. 系统指令

   * Y86: halt, nop
   * THINPAD: nop
   * x处理器计划实现: halt, nop

7. 寄存器传送指令

   * Y86: rrmovl, irmovl, cmovXX

   * THINPAD: li, mfih, mfpc, move, mtih, mtsp

   * 比较以上两个处理器的指令，计划x处理器实现以下指令：

     rrmov, irmov

8. 外设IO指令

   - x处理器计划实现的IO指令：in, out

   - 目前考虑不可或缺的设备管理器有：

     **内存管理器**：提供内存的状态(我想最重要的内存状态是内存大小)，端口号为3

     **键盘管理器**：提供用户输入，端口号为0

     **显示管理器**：提供用户输出，端口号为1

     **时钟管理器**：提供时间以实现进程切换,端口号为4

9. 其它指令

   * Y86, THINPAD和V9均没有原子操作指令，但从ucore的学习可见原子操作指令是很重要的，需要考虑实现TS指令和swap指令的问题。
   * 人工智能指令，感觉挺有趣，但完全不懂，目前没有实现的计划。


